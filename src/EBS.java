import VirtualDevices.*;
import electronicBrake.*;
import electronicBrake.enums.*;
import java.util.ArrayList;
import java.util.List;

/**
 * CS 460 : Electronic Braking System
 * <p>
 * The EBS is called by the brake simulation through update(), and it is
 * through this method that the functions of the EHBS are carried out.
 * The EBS object will be responsible for storing the state of the electronic
 * brake and using that state to carry out functions through Events, Actions,
 * and Rules.
 *
 * @author James Perry (original author)
 * @author Antonio Griego (adaptations and edits for Group 1)
 */
public class EBS
{
  private StateType state;
  private StateType previousState;

  // Controller Sub-Objects:
  private final Actions actions;
  private final Rules rules;
  private final Events events;

  /**
   * Constructor which initialises the references to the Controller Sub-Objects.
   */
  public EBS(BrakeButton brakeButton, BrakeController brakeController, VehicleElectronics vehicleElectronics,
             AlarmNotification alarmNotification, LEDNotification ledNotification)
  {
    state = StateType.NULL;
    previousState = StateType.NULL;

    BrakeControl brakeControl = new BrakeControl(brakeController);

    this.actions = new Actions(brakeControl, alarmNotification, ledNotification);
    this.rules = new Rules();
    this.events = new Events(brakeControl, brakeButton, vehicleElectronics);
  }

  /**
   * This is the method called by the simulation once per time
   * step in order to run the Electronic Brake logic.
   */
  public void update()
  {
    updateState(getEventsList());
    executeActions(rules.getActions(state));
  }

  /**
   * This method executes a list of actions generated by the Rules module.
   *
   * @param actionsList a list of actions to be performed
   */
  private void executeActions(List<ActionTypes> actionsList)
  {
    // There is one case where the list of actions will be null, i.e., where
    // there will be no actions performed: the initial NULL state.
    if (actionsList != null)
    {
      for(ActionTypes action : actionsList)
      {
        actions.execute(action);
      }
    }
  }

  /**
   * This method checks for applicable states depending on the state of the EBS
   * by checking the Rules module.
   *
   * @return a list of events that HAVE occurred from the given checklist
   */
  private List<EventTypes> getEventsList()
  {
    List<EventTypes> potentialEventsList = rules.getEvents(state);
    List<EventTypes> eventsList = new ArrayList<>();

    for(EventTypes potentialEvent : potentialEventsList)
    {
      if(events.didEventOccur(potentialEvent))
      {
        eventsList.add(potentialEvent);
      }
    }

    return eventsList;
  }

  /**
   * This method updates the state of the EBS and its previous state depending on the
   * events that have recently occurred and its current state.
   *
   * @param eventsList a list of events that have occurred during the current time step
   */
  private void updateState(List<EventTypes> eventsList)
  {
    // System.out.println("state: " + state + "\nnumber of events: " + eventsList.size() + "\n");

    switch(state)
    {
      case NULL:
        if(isEngagedAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isEngagedAndNotParked(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_ENGAGED;
        }
        else if(isDisengagedAndNotParked(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_DISENGAGED;
        }
        else if(isDisengagedAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
        break;

      case PARKED_ENGAGED:
        if(isShortPress(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
        else if(isNotParked(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_ENGAGED;
        }
        else if(isShortPressAndNotParked(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_DISENGAGED;
        }
        break;

      case PARKED_DISENGAGED:
        if(isShortPress(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isNotParked(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_DISENGAGED;
        }
        else if(isShortPressAndNotParked(eventsList))
        {
          previousState = state;
          state = StateType.WARN;
        }
        break;

      case NOT_IN_PARK_ENGAGED:
        if(isShortPress(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_DISENGAGED;
        }
        else if(isParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isShortPressAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
        break;

      case NOT_IN_PARK_DISENGAGED:
        if(isShortPress(eventsList))
        {
          previousState = state;
          state = StateType.WARN;
        }
        else if(isParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isShortPressAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
        break;

      case WARN:
        if(isLongPress(eventsList))
        {
          previousState = state;
          state = StateType.ENGAGING;
        }
        else if(isParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
        else if(isReleased(eventsList))
        {
          // The implementation here is implied but not explicitly stated
          // by the specification... it might be problematic.
          previousState = StateType.NULL;
          state = previousState;
        }
        else if(isLongPressAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        break;

      case ENGAGING:
        if(isShortPress(eventsList))
        {
          previousState = state;
          state = StateType.ENGAGING_WARN;
        }
        else if(isParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isEngaged(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_ENGAGED;
        }
        else if(isEngagedAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isShortPressAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
        break;

      case ENGAGING_WARN:
        if(isLongPress(eventsList))
        {
          previousState = state;
          state = StateType.NOT_IN_PARK_DISENGAGED;
        }
        else if(isParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_ENGAGED;
        }
        else if(isReleased(eventsList))
        {
          previousState = state;
          state = StateType.ENGAGING;
        }
        else if(isLongPressAndParked(eventsList))
        {
          previousState = state;
          state = StateType.PARKED_DISENGAGED;
        }
    }
  }

  /*
   * The following helper functions implement boolean checks needed for the updateState method.
   */

  private boolean isEngagedAndParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.ENGAGED) && e.contains(EventTypes.PARKED) && e.size() == 2);
  }

  private boolean isEngagedAndNotParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.ENGAGED) && e.contains(EventTypes.NOT_PARKED) && e.size() == 2);
  }

  private boolean isDisengagedAndNotParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.DISENGAGED) && e.contains(EventTypes.NOT_PARKED) && e.size() == 2);
  }

  private boolean isDisengagedAndParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.DISENGAGED) && e.contains(EventTypes.PARKED) && e.size() == 2);
  }

  private boolean isShortPress(List<EventTypes> e)
  {
    return (e.contains(EventTypes.SHORT_PRESS) && e.size() == 1);
  }

  private boolean isNotParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.NOT_PARKED) && e.size() == 1);
  }

  private boolean isShortPressAndNotParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.SHORT_PRESS) && e.contains(EventTypes.NOT_PARKED) && e.size() == 2);
  }

  private boolean isParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.PARKED) && e.size() == 1);
  }

  private boolean isShortPressAndParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.SHORT_PRESS) && e.contains(EventTypes.PARKED) && e.size() == 2);
  }

  private boolean isLongPress(List<EventTypes> e)
  {
    return (e.contains(EventTypes.LONG_PRESS) && e.size() == 1);
  }

  private boolean isReleased(List<EventTypes> e)
  {
    return (e.contains(EventTypes.RELEASED) && e.size() == 1);
  }

  private boolean isLongPressAndParked(List<EventTypes> e)
  {
    return (e.contains(EventTypes.LONG_PRESS) && e.contains(EventTypes.PARKED) && e.size() == 2);
  }

  private boolean isEngaged(List<EventTypes> e)
  {
    return (e.contains(EventTypes.ENGAGED) && e.size() == 1);
  }
}